\section{Related Work\\}

\subsection{Event-driven Systems\\}

The paper\cite{David} evaluated several strategies to achieve concurrency
for web servers. The authors compared performance of different concurrent models:
multi-process, multi-thread, event-driven, etc.  As the experimental 
results reveal, the event-driven $\mu$-server performed better than 
multithreading or multiprocessing models
    
In the famous technical report\cite{C10K}, Kegel performed detailed
benchmark on several I/O strategies. The report compares different 
system supports for the I/O multiplexing(which are the foundation
of event-driven programming): select(), poll(), epoll() and kqueue() 
and argues that the implementation of epoll() and select() makes them
scales poorly while the epoll() and kqueue() performs much better as
they avoid active pollings to the system kernels.

\subsection{Server Push technologies\\}

In \cite{Engin}, Bozdag \emph{et al} provided complete comparisons 
and evaluation of different types of server push technologies, including the 
HTTP pull, Flash XML socket, Java RMI, long polling etc. As a conclusion the
authors stated that "an event-driven model on the server side is necessary" 
owing to its , lower consumption of the computing resource, less network
traffic etc.

Another paper \cite{duquennoy09consistency} performs the quantitative 
analysis of the consistency and scalability of several different server
push technologies. As the experimental results showed the event-driven
long polling model shows an excellent efficiency and scalability.

